import pandas as pd 
import streamlit as st
from sklearn.model_selection import train_test_split
from lightgbm import LGBMClassifier

from PIL import Image
import plotly.figure_factory as ff
import plotly.express as px

image = Image.open('/Users/candido/Desktop/Data Science/Projeto Tera/tera_banner.png')

st.image(image, use_column_width=True)

# t√≠tulo
st.title("Desengajamento de clientes de um app de sa√∫de üì±üç≤üèÉ‚Äç‚ôÄÔ∏èüßò‚Äç‚ôÇÔ∏è")

st.write("O app de sa√∫de estudado √© uma plataforma que conta com uma equipe multidisciplinar, com nutricionistas, psic√≥logos e treinadores, que auxiliam os clientes em programas de emagrecimento, vida saud√°vel e ganho de massa. O aplicativo cont√©m card√°pios, listas de compras, protocolos de jejum intermitente, exerc√≠cios, medita√ß√µes e conte√∫dos.")

st.write("Tendo impactado a vida de milh√µes de pessoas, atualmente conta com 30 mil instala√ß√µes e 60 mil usu√°rios √∫nicos por semana.")

st.write("Nesta p√°gina, ser√£o apresentadas informa√ß√µes sobre a atividade dos usu√°rios de acordo com caracter√≠sticas espec√≠ficas e, ao final, ser√£o expostos os resultados de um modelo de previs√£o que indica quais os usu√°rios com a maior probabilidade de desengajarem.")

# dataset
df = pd.read_csv('/Users/candido/Desktop/Data Science/Projeto Tera/data_limpo2.csv')


#### POR CARACTER√çSTICAS DO USU√ÅRIO ####
st.header("Cohorts:")
st.write("Ser√£o mostrados gr√°ficos que revelam a quantidade de dias que os usu√°rios entram no app, agrupados de acordo com caracter√≠sticas espec√≠ficas.")

st.write("No geral, os usu√°rios entram no aplicativo em 19 dias (em m√©dia) diferentes. O heatmap a seguir traz um cohort geral e mensal, de outubro de 2019 a dezembro de 2021, o que ser√° detalhado por grupos espec√≠ficos nos cohorts seguintes.")



st.image('1_cohort_mensal.png', use_column_width=True)


st.subheader("Cohorts de acordo com caracter√≠sticas do usu√°rio:")


select = st.selectbox('Escolha um cohort para visualiza√ß√£o:', ('Escolha', 'Faixa et√°ria', 'G√™nero', 'Faixas de peso desejado', 'Objetivo do usu√°rio'))
if select == 'Escolha':
    pass
elif select == 'Faixa et√°ria':
    st.image('3_faixa_etaria.png', use_column_width=True)
    st.caption("Os usu√°rios de faixas et√°rias mais elevadas entram, em m√©dia, mais dias no aplicativo do que os usu√°rios mais jovens. Isso tamb√©m √© refletido no cohort de engajamento ao longo dos dias: no 20¬∫ dia, temos mais de 20% dos usu√°rios das faixas dos 40 aos 70 anos, enquanto que para os usu√°rios de 20 a 30 anos esse percentual √© de apenas 12%.")

elif select == 'G√™nero':
    st.image('2_genero.png', use_column_width=True)
    st.caption("Os usu√°rios do g√™nero masculino entram no app 15 dias (em m√©dia), enquanto as mulheres entram em m√©dia 20 dias. Isso tamb√©m √© refletido no cohort de engajamento ao longo dos dias: no 20¬∫ dia, temos 18% dos usu√°rios do g√™nero feminino e apenas 13% do masculino.")

elif select == 'Faixas de peso desejado':
    st.image('5_peso.png', use_column_width=True)
    st.caption("Os usu√°rios que est√£o em faixas mais elevadas, seja de emagrecimento ou de ganho de massa, entram em m√©dia menos dias no aplicativo. Isso tamb√©m √© refletido no cohort de engajamento ao longo dos dias: no 20¬∫ dia, temos 20% dos usu√°rios da faixa de emagrecimento de at√© 10 kg, enquanto que para os usu√°rios que querem emagrecer entre 30 e 40 kg ou ganhar mais de 10 kg esse percentual √© de apenas 15% e 10%, respectivamente.")

elif select == 'Objetivo do usu√°rio':
    st.image('4_objetivo.png', use_column_width=True)
    st.caption("Os usu√°rios que querem perder peso s√£o os mais representativos e entram em m√©dia 21 dias no aplicativo. Observando o cohort de engajamento, no 20¬∫ dia temos 19% dos usu√°rios que querem perder peso e apenas 9% dos que querem ganhar massa (segunda maior categoria).")


### POR PARTICIPA√á√ÉO NO APLICATIVO ###
st.subheader("Cohorts dos usu√°rios de acordo com a utiliza√ß√£o do aplicativo:")

option = st.selectbox('Escolha um cohort para visualiza√ß√£o:', ('Escolha', 'Plataforma', 'Inscri√ß√£o', 'N√∫mero de programas', 'N√∫mero de posts', 'An√°lise nutricional', 'Treinos', 'Medita√ß√µes', 'Di√°rio de refei√ß√µes'))
if option == 'Escolha':
    pass
elif option == 'Plataforma':
    st.image('7_platform.png', use_column_width=True)
    st.caption("Os usu√°rios de Android e iOS t√™m um comportamento parecido em rela√ß√£o √† quantidade de dias que entraram no aplicativo. No cohort de engajamento vemos que no 20¬∫ dia, temos 17% e 19% dos usu√°rios de Android e iOS, respectivamente.")

elif option == 'Inscri√ß√£o':
    st.image('8_is_program_enrolled.png', use_column_width=True)
    st.caption("No cohort de engajamento vemos que no 20¬∫ dia temos 21% dos usu√°rios que est√£o inscritos em programas. Para os usu√°rios que n√£o est√£o inscritos em programas, esse percentual √© de 15%.")

elif option == 'N√∫mero de programas':
    st.image('9_n_programs.png', use_column_width=True)
    st.caption("Os usu√°rios que se inscrevem em mais programas entram em m√©dia mais dias no aplicativo. A quantidade de programas em que o usu√°rio se inscreveu poderia ser apenas uma proxy do tempo que o usu√°rio permaneceu no aplicativo. O que √© interessante notar no cohort de engajamento √© que, desde o in√≠cio, usu√°rios que v√£o se inscrever em mais programas ao longo de sua vida no aplicativo engajam mais. No 20¬∫ dia, temos quase 35% dos usu√°rios que se inscreveram em quatro ou cinco programas. Esse n√∫mero cai para apenas 12% para aqueles que n√£o se inscreveram ou que se escreveram em apenas um programa.")

elif option == 'N√∫mero de posts':
    st.image('10_posts', use_column_width=True)
    st.caption("Pela vis√£o do cohort tamb√©m fica bastante evidente a diferen√ßa entre o engajamento dos usu√°rios que fizeram um post e daqueles que n√£o o fizeram. No 20¬∫ dia, temos apenas 13% dos usu√°rios que nunca fizeram um post e 41% daqueles que fizeram.")

elif option == 'An√°lise nutricional':
    st.image('11_nutritional.png', use_column_width=True)
    st.caption("Pela vis√£o do cohort fica bastante evidente a diferen√ßa entre o engajamento dos usu√°rios que fizeram an√°lise nutricional e daqueles que n√£o o fizeram. No 20¬∫ dia, temos apenas 17% dos usu√°rios que nunca fizeram uma an√°lise e 47% daqueles que fizeram.")

elif option == 'Treinos':
    st.image('12_treino.png', use_column_width=True)
    st.caption("O cohort mostra a diferen√ßa entre o engajamento dos usu√°rios que realizaram treinos e daqueles que n√£o fizeram. No 20¬∫ dia, temos apenas 15% dos usu√°rios que nunca fizeram um treino e 36% daqueles que fizeram.")

elif option == 'Medita√ß√µes':
    st.image('13_meditation.png', use_column_width=True)
    st.caption("O cohort indica a diferen√ßa entre o engajamento dos usu√°rios que realizaram medita√ß√µes e daqueles que n√£o o fizeram. No 20¬∫ dia, temos apenas 16% dos usu√°rios que nunca fizeram uma medita√ß√£o e 40% daqueles que fizeram.")

elif option == 'Di√°rio de refei√ß√µes':
    st.image('14_diario.png', use_column_width=True)
    st.caption("O cohort deixa evidente a diferen√ßa entre o engajamento dos usu√°rios que registraram refei√ß√µes e daqueles que n√£o fizeram. No 20¬∫ dia, temos apenas 3% dos usu√°rios que nunca fizeram um registro e 21% daqueles que fizeram.")

st.header("Modelo de predi√ß√£o:")

st.write("O grande objetivo do trabalho foi construir um modelo de predi√ß√£o para verificar quais os clientes com as maiores probabilidades de desengajamento do aplicativo, o que possibilitaria a execu√ß√£o de a√ß√µes direcionadas para prevenir o churn.")
st.write("O modelo utilizado para predi√ß√£o √© o LightGBM, que √© constru√≠do a partir de algorimos de √°rvores de decis√£o. Aqui ser√£o mostrados os IDs dos 200 clientes com maior probabilidade de desengajamento, ordenados da maior para a menor probabilidade.")


#### ---------------- LIGHTGBM  ---------------- ####

# Json special characters fix
import re
df = df.rename(columns = lambda x:re.sub('[^A-Za-z0-9_]+', '', x))

# Definir x e y
x = df.drop(['target', 'id'], axis=1)
y = df['target']

# Definir x_train e y_train, x_test e y_test
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=42)

# # Rodar o modelo
st.subheader("Esses s√£o os clientes com a maior probabilidade de desengajamento:")

# LGBMClassifier

lgbm_model = LGBMClassifier(
    random_state=42,
    scale_pos_weight = 0.15, # para tratar o balanceamento
    learning_rate = 0.008,
    num_leaves = 13,
    min_child_samples = 65,
    subsample = 0.86,
    colsample_bytree = 0.53,
    n_estimators=973,
    subsample_freq = 7
)
lgbm_model.fit(x_train, y_train)

lgbm_pred = lgbm_model.predict(x_test)

lgbm_prob = lgbm_model.predict_proba(x_test)[:,1]

# selecionar os clientes que apresentam predi√ß√£o igual a 1
lgbm_pred_1 = lgbm_model.predict(x_test)[lgbm_pred == 1]

lgbm_prob_df = pd.DataFrame({'ID': x_test.index, 'prob': lgbm_prob})


lgbm_prob_df = lgbm_prob_df.sort_values('prob', ascending=False)
lgbm_prob_df = lgbm_prob_df.reset_index(drop=True)
lgbm_prob_df_head = lgbm_prob_df.head(200)

if st.button('Rodar modelo'):
    col1, col2, col3 = st.columns(3)
    col2.write(lgbm_prob_df_head.iloc[:, 0], use_column_width=True)



# XGBoost

# xgb_model = XGBClassifier(
#     n_estimators=500, 
#     learning_rate=0.01,
#     max_depth=7,
#     subsample = 0.75,
#     colsample_bynode=0.75,
#     min_child_weight= 40,
#     scale_pos_weight = 0.15 # para balancear o problema de classifica√ß√£o = total negative examples / total positive examples
# )
# xgb_model.fit(x_train, y_train)

# # xgb_pred = xgb_model.predict(x_test)

# xgb_prob = xgb_model.predict_proba(x_test)[:,1]

# # create a dataframe with 'id' and 'xgb_prob'
# xgb_prob_df = pd.DataFrame({'id': x_test.index, 'xgb_prob': xgb_prob})

# # ordenar xgb_prob_df por xgb_prob, da maior para a menor
# xgb_prob_df = xgb_prob_df.sort_values(by='xgb_prob', ascending=False)
# # retirar index
# xgb_prob_df = xgb_prob_df.reset_index(drop=True)
# xgb_prob_df_head = xgb_prob_df.head(200)

# #criando 3 colunas 
# col1, col2, col3 = st.columns(3)
# #inserindo na coluna 2
# col2.write(xgb_prob_df_head, use_column_width=True)
